---
title: "CWD2027-2024 data processing"
author: "Lily Pitcher"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = here::here())
                       #"/Users/lilyp/OneDrive - Smithsonian Institution/Documents/D-woody debris/FILES FOR CODE")
```

```{r}
#load packages
rm(list=ls())
library(knitr)
library(report)
library(tidyr)
library(dplyr)
library(here)
```

```{r}
#load in all the files
  #data from destructve sample with density lab measurements for model
LTDATA2010<-"Data0_Raw/LongT_CWD_2010.csv"
#main data
DPDATAFALLEN<-"Data2_Corrected/corrected_CWD40_fallen_17to24.csv"
DPDATASTANDING<-"Data2_Corrected/corrected_CWD40_standing_17to24.csv"

BCI_2010_longtransectsCWD<-read.csv(LTDATA2010)

```



start by creating the model from BCI_2020_longtransects that allows density prediction from penetrometer mm per hits.
This model is done following the methods described in Gora et al 2019
```{r}
attach(BCI_2010_longtransectsCWD)
str(BCI_2010_longtransectsCWD)
#create a linear regression model of the relationship between log density and log penetretion per hit (mm)
LOGdense <- log10((dry.density.gm3/1000))
LOGpen <- log10(pen.hit.mm)
mod1 <- lm(LOGdense ~ LOGpen)
summary_mod1<-summary(mod1)
#extract the residual standard error error
RSE<-summary_mod1$sigma
#calculate correction factor 
CF<- 10^((RSE^2) / 2)

b0 <- coef(mod1)[1]  # Intercept
b1 <- coef(mod1)[2]  # Slope

# Print outputs
cat("Correction Factor (CF):", CF, "\n")
cat("Equation: log10(Density) =", round(b0, 3), "+", round(b1, 3), "* log10(Penetration per hit)\n")

# Show model summary
print(summary_mod1)
```

```{r}

plot(LOGpen, LOGdense, main = "Log 10 density kgm3-Log penetration per hit mm Linear Regression", 
     xlab = "Log 10 (penetration per hit mm)", ylab = "Log 10 (density kgm3)", 
     pch = 16, col = "blue")

# Add regression line
abline(mod1, col = "red", lwd = 2)

# Add legend
legend("topright", legend = c("Data points", "Regression line"), 
       col = c("blue", "red"), pch = c(16, NA), lty = c(NA, 1))

```


#FUNCTIONS


```{r}

#PREDICTING THE DENSITY OF A PIECE USING THE MODEL

#calculate penetration per hit
#first one is for samples where 20 hits were done and the mm depth was measured
#values reperesent mm 

PENPERHIT <- function(indata) {
  indata <- indata %>%
    dplyr::mutate(
      pen.hit.mm = dplyr::case_when(
        !is.na(penetration.200mm) ~ penetration.200mm / 20,
        !is.na(penetration.200mm.1) ~ 200 / penetration.200mm.1,
        TRUE ~ NA_real_
      )
    )
  return(indata)
}

#model the density from mm per hit
predictdensity <- function(indata, mod1, CF) {
  indata <- indata %>%
    mutate(
      log_penetration = log10(pen.hit.mm),
      pendensity.kgm3 = ifelse(
        !is.na(log_penetration), 
        10^(predict(mod1, newdata = data.frame(LOGpen = log_penetration))) * CF,
        NA ) )
  return(indata)
}


#for missing density values from and for the years of 2021 to 2024 will use the average wood density (271 kg m3) taken from Gora et al 2019
AVERAGEDENSITY<-function(indata){
  indata<-indata %>%
    dplyr::mutate(pen_density= if_else(!is.na(pen.hit.mm), 
                                       TRUE,
                                       FALSE)) %>%
    dplyr::mutate(pendensity.kgm3= if_else(is.na(pendensity.kgm3),
                                           271,
                                           pendensity.kgm3)) %>%
    dplyr::select(!log_penetration)
  return(indata)
  }
```



#Applying functions to DOWNED CWD

```{r}
#Applying the functions to downed cwd data from 2017-2024
fallen_data<-read.csv(DPDATAFALLEN,header=TRUE, sep=",")
fallen_data<-PENPERHIT(fallen_data)
fallen_data<-predictdensity(fallen_data, mod1, CF)
fallen_data<-AVERAGEDENSITY(fallen_data)

```


## Additional functions
```{r}
#calculating cross section mass from density and diameter data
#for downed debris we calculate the cross section area of the location where the sample crosses the transect
CROSSSECTIONMASS<-function(indata) {
  indata<-indata %>%
    dplyr::mutate(pen_crossmass.kgm=(pendensity.kgm3*(((diameter_width.mm/(1000*2))^2)*pi)))
  return(indata)
  }
fallen_data<-CROSSSECTIONMASS(fallen_data)
```



```{r}
#calculating diameter squared in meters
DIAMETERSQAUREDCONVERTED<-function(indata) {
  indata<-indata %>%
    dplyr::mutate(diam_sqr_m = ((diameter_width.mm/1000)^2))
  return(indata)
}
fallen_data<-DIAMETERSQAUREDCONVERTED(fallen_data)
```







# Applying functions to STANDING CWD


```{r, warning=FALSE}
standing_data<-read.csv(DPDATASTANDING, header=TRUE)
standing_data<-PENPERHIT(standing_data)
standing_data<-predictdensity(standing_data, mod1, CF)
standing_data<-AVERAGEDENSITY(standing_data)
```


## Additional functions
```{r, include=FALSE}
# Diameter corrections
#. Apply taper correction to standing deadwood to correct for measurement where dbh was measured at a different point to 1.3m
taper_function <- function(indata) {
  # 1. calculating taper correction parameter (b) using the parameters from Table 3 of Cushman et al. 2014 Methods Ecology and Evolution 
  # and including the correction factor for back-transforming from log - CF = exp((RSE^2)/2) where RSE = 0.685 in this case 
  # POM assumed to be in meters and diameter in cm, hence conversion 
  indata$b <- ifelse(!is.na(indata$POM), 
                     exp((0.685^2)/2)*
                       (exp(-2.0205 - 0.5053 * log(indata$diameter_one.mm/10) + 
                              0.3748 * log(indata$POM))),
                     NA)
  #calculating new dbh correcting for point of measurement using model from Table 1, model 1 of of Cushman et al. 2014 Methods Ecology and Evolution
  indata$mean_diameter_at1.3_mm <- ifelse(!is.na(indata$POM),
                                      indata$diameter_one.mm * exp(indata$b * (indata$POM - 1.3)),
                                      indata$diameter_one.mm)
  return(indata)
}

# Diameter corrections
#. Apply taper correction to standing deadwood to correct for measurement where dbh was measured at a different point to 1.3m
taper_function2 <- function(indata) {
  # 1. calculating taper correction parameter (b) using the parameters from Model 2 of Cushman et al. 2021 Biotropica - parameters in Table 2, model 2, and in Table S9 
  # Model 2 preferred because we lack WSG data for each piece.  
  # model assumes POM in meters and diameter in cm so note conversion from diameter in mm
  indata$b <- ifelse(!is.na(indata$POM), 
                     0.156 - 0.023 * log(indata$diameter_one.mm/10) + 
                      -0.021 * log(indata$POM) + 
                       0.00057,  # random effect for BCI for model 2. 
                     NA)
 #calculating new dbh correcting for point of measurement using model from Table 1, model 1 of of Cushman et al. 2014 Methods Ecology and Evolution
  indata$mean_diameter_at1.3_mm <- ifelse(!is.na(indata$POM),
                                      indata$diameter_one.mm * exp(indata$b * (indata$POM - 1.3)),
                                      indata$diameter_one.mm)
  return(indata)
}

# DIAMTER AT TOP OF PIECE
# for trees with no branches they are treated as truncated cone, so the taper function is used to estimate the diameter at the top of the tree
# branches==2 - no branches  
top_diameter<-function(indata){
  indata$Diameter.at.top.of.snag<-ifelse(indata$branches == 2,
                                         indata$mean_diameter_at1.3_mm * 
                                           exp(indata$b * (1.3-indata$height)), NA)
  return(indata)
}

standing_data<-taper_function2(standing_data)
standing_data<-top_diameter(standing_data)

```



```{r}
#calculating volume of standing pieces
# Standing pieces are treated differently based on number of branches remaining, explanation of branches variable:
# NA means this variable was not recorded
# 2 means there are no longer branches present
# 1 means part of the canopy has been lost, some branches fallen
# 0 means the majority of the canopy is still present, very few branches lost

# This formula calculates the volume of the standing tree, 
VOLUMECALCULATION <- function(indata) {
  indata$volume_m3<-
    ifelse(indata$branches==2,  # NO BRANCHES, so approximated as a truncated cone 
           (1/3) * pi * indata$height * (
             ((indata$Diameter.at.top.of.snag/1000) / 2) ^ 2 + 
               ((indata$Diameter.at.top.of.snag/1000) / 2) * ((indata$mean_diameter_at1.3_mm/1000) / 2) + 
               ((indata$mean_diameter_at1.3_mm/1000) / 2) ^ 2),
           
           ifelse(indata$branches==1, # SOME BRANCHES, but some were lost, which is accounted for by multiplying volume of a cylinder by 0.875 - AS DONE IN (Chave 2014 and Gora 2019)
                   (pi * (((indata$mean_diameter_at1.3_mm/1000) / 2) ^ 2) * indata$height)*0.875,
                   
           ifelse(indata$branches==0|is.na(indata$branches), # ALL BRANCHES PRESENT (none lost), approximated as a cylinder
                  pi * (((indata$mean_diameter_at1.3_mm/1000) / 2) ^ 2) * indata$height,
                   NA)))
  indata$volume_m3<-indata$volume_m3
  return(indata)
}

# This formula calculates the above ground biomass of the standing tree, 
AGBCALCULATION<-function(indata) {
  indata$AGB.kg.dry.mass<-
    ifelse(indata$branches==2, #calculating agb of samples NO BRANCHES- density is multiplied by volume
           indata$volume_m3*indata$pendensity.kgm3,
           
           ifelse(indata$branches==1,  #calculating agb of samples with SOME BRANCHES lost, using environment specific biomass function multiple by 0.975 as 87.5%  - (Chave 2014 and Gora 2019)
       (exp(-1.803 - 0.976 * 0.0561 + 0.976 * log(indata$pendensity.kgm3) + 2.673 * log((indata$mean_diameter_at1.3_mm*0.01)) -
              0.0299*(log((indata$mean_diameter_at1.3_mm*0.01))^2)))*0.875,
       
       ifelse(indata$branches==0|is.na(indata$branches), #calculating agb of samples with ALL BRANCHES using environment specific biomass function (Chave 2014 and Gora 2019)
       exp(-1.803 - 0.976 * 0.0561 + 0.976 * log(indata$pendensity.kgm3) + 2.673 * log((indata$mean_diameter_at1.3_mm*0.01)) -
             0.0299*(log((indata$mean_diameter_at1.3_mm*0.01))^2)),

       NA)))
  return(indata)
  }

standing_data<-VOLUMECALCULATION(standing_data)
standing_data<-AGBCALCULATION(standing_data)
```



#Functions for calculating residence time and decay 

```{r}

#calculating exponential decay rate, can be applied to different measurements (variable) based on what it was possible to measure
DECAYCALCULATION <- function(indata, variable, output) {
  indata <- indata %>%
    dplyr::arrange(code_of_piece, year) %>%
    dplyr::group_by(code_of_piece) %>%
    #equation is log of current year/previous year value#
    dplyr::mutate({{output}} := log({{variable}} / lead({{variable}})))
  return(indata) 
  }  
```



```{r}
  #decay
fallen_data<-DECAYCALCULATION(fallen_data, diameter_width.mm, k.diameter.yr )
fallen_data<-DECAYCALCULATION(fallen_data, pen_crossmass.kgm, k.csarea.yr ) 
standing_data<-DECAYCALCULATION(standing_data, volume_m3,k.volume.yr )
standing_data<-DECAYCALCULATION(standing_data, AGB.kg.dry.mass, k.mass.yr )

```


# HABITAT
assigning habitat class to data, subplot within the 50ha have been assigned habitat types
```{r}
#loading and organizing habitat data
habitat<-"Dat0_Raw/bci_q20habitat_classes"
subplot<-"Dat0_Raw/subplot_codes.txt"


habitat<-read.table(habitat,header=TRUE, sep="\t")
subplot<-read.table(subplot, header=TRUE, sep="\t")

habitat$x<-habitat$x/20
habitat$y<-habitat$y/20
habitat$x <- sprintf("%02d", habitat$x)
habitat$y <- sprintf("%02d", habitat$y)
habitat$subplot_code<-paste(habitat$x, habitat$y, sep=",")

habitat_subplot<- habitat %>%
  semi_join(subplot, by = "subplot_code")
habitat_subplot<-habitat_subplot %>%
  select("subplot_code", "habitat")
```

```{r}
#assigning habitat class to data based on suplot code
fallen_data<-merge(fallen_data, habitat_subplot)
standing_data<-merge(standing_data, habitat_subplot)
rm(habitat, habitat_subplot, subplot)
```





```{r}
write.csv(fallen_data, file = "Data3_Processed/processed_CWD40_fallen_17to24.csv",  col.names = TRUE, row.names = FALSE)
write.csv(standing_data, file = "Data3_Processed/processed_CWD40_standing_17to24.csv",  col.names = TRUE, row.names = FALSE)


```


















